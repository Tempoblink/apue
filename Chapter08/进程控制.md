## 8进程控制

### 8.2进程标识

每个进程都有一个唯一非负整型表示的进程id。

> 因为进程id总是唯一的，常将其用做其他表示符的一部分以保证其唯一性。

虽然进程id时唯一的，但是是可复用的。当一个进程终止后，其进程id就成为复用的候选者。

> 大多数unix系统采用延迟复用算法，使得赋予新建进程的id不同于最近终止进程所使用的id。

系统中有一些专用进程：

- id为0的进程通常是调度进程，也常被称为交换进程(swapper)。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。
- id为1的进程通常是init进程，在系统自举过程结束时由内核调用。此进程负责在自举内核后启动一个unix系统。`init`通常读取与系统有关的初始化文件(`/etc/rc*`文件或`/etc/initab`文件，以及在`/etc/init.d`中的文件)，并将系统引导到一个状态(如多用户)。

> init进程的程序文件在unix早期版本中的是`/etc/init`，在较新版本中是`/sbin/init`。init进程绝不会终止。它是一个普通用户进程(与交换进程不同，它不是内核中的系统进程)，但是以root用户运行。

- id为2的进程是页守护进程(page deamon)，此进程负责支持虚拟内存系统的分页操作。

除了进程id，每个进程还有一些其他标识符。下列函数返回这些标识符。

```c
#include<unistd.h>
pid_t getpid(void);
//函数的返回值：调用进程的进程id
pid_t getppid(void);
//函数的返回值：调用进程的父进程id
uid_t getuid(void);
//函数的返回值：调用进程的实际用户id
uid_t geteuid(void);
//函数的返回值：调用进程的有效用户id
gid_t getgid(void);
//函数的返回值：调用进程的实际组id
git_t getegid(void);
//函数的返回值：调用进程的有效组id
```

> 注意，这些函数均不会出错返回。

### 8.3函数fork

调用`fork()`可以创建一个新进程。

```c
#include<unistd.h>
pid_t fork(void);
//函数的返回值：子进程返回0，父进程返回子进程id；若出错，返回-1
```

由`fork()`创建的新进程被称为子进程(child process)。

关于函数的返回值有两种情况的原因：

- 父进程进程的子进程可以有多个，且没有一个函数可以获得子进程的进程id。


- 一个进程只会有一个父进程，而进程总是可以调用`getppid()`获得父进程的进程id。

> 进程id0总是由内核交换进程使用，所以子进程的进程id不可能是0。

子进程者父进程继续执行`fork()`调用之后的指令。子进程是父进程的副本。子进程获得父进程数据空间、堆和栈的副本。但父进程和子进程并不共享这些内存空间位置。父进程和子进程只共享.text段。

子进程的虚拟内存区使用写时复制计数(Copy-On-Write，COW)。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟内存系统中的虚拟页。

一般来说，在`fork()`之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。

`strlen()`与`sizeof()`的区别：

1. `strlen()`计算不包含终止`null`字节的字符串长度。而`sizeof()`则计算包括终止`null`字节的缓冲区长度。
2. 使用`strlen()`需进行一次函数调用，而`sizeof()`是在编译时就可知的。

> 若在`fork()`之前调用`printf()`，则当调用`fork()`时，该行数据仍在缓冲区中，在将父进程数据空间复制到子进程中时，该缓冲区也被复制到子进程中。

#### 8.3.1文件共享

`fork()`的一个特性是父进程的`fd`表会被复制到子进程中。父进程和子进程每个相同的`fd`共享一个文件表项。(`dup2()`特性)

除了打开文件之外，父进程的很多其他属性也被子进程复制，这些属性如下：

- 标识符类：
  - 实际用户id、实际组id、有效用户id、有效组id
  - 附属组id
  - 进程组id
  - 会话id
  - 程序的设置用户id标志和设置用户组id标志

- 进程环境类：
  - 控制终端
  - 当前工作目录
  - 根目录
  - 创建文件时的权限屏蔽字
  - 对任一打开`fd`的执行时关闭(close-on-exec)标志
  - 环境变量
  - 链接的共享内存段。(动态库)
  - 内存映射
  - 资源限制

父进程和子进程之间的区别具体如下：

- `fork()`的返回值不同
- 进程id不同，两进程的父进程id也不同。
- 子进程的`tms_utime`、`tms_stime`、`tms_cutime`和`tms_ustime`的值设置为0
- 子进程不继承父进程设置的文件锁
- 子进程的未处理`alarm`被清除
- 子进程的未处理信号集设置为空集

使`fork()`失败的两个主要原因是：

1. 系统中已经有了太多的进程
2. 该实际用户id的进程总数超过了系统限制，`CHILD_MAX`规定了每个实际用户id在任一时刻可拥有的最大进程数。

`fork()`有以下两种用法：

1. 一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。
2. 一个进程要执行一个不同的程序。即子进程`fork()`返回后立即调用`exec`函数。

### 8.4函数vfork

`vfork()`的调用序列和返回值与`fork()`相同，但两者的语义不同。

- `vfork()`用于创建一个子进程，而该子进程的目的是执行一个新程序。

- 由于`vfork()`并不完全复制父进程的虚拟内存空间，且在子进程调用`exec`或`exit()`之前，它在父进程的空间中运行。因此存在以下情况都可能会带来未知的结果：
  - 若子进程修改数据(除了用于存放`vfork()`返回值的变量)
  - 进行函数调用
  - 没有调用`exec`或`exit()`就返回

- `vfork()`保证子进程先运行，在它调用`exec`或`exit()`之后父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程回恢复运行。

### 8.5函数exit

如7.3节所述，进程有5种正常终止和3种异常终止方式。

- 5种正常终止方式有：
  - 在main函数内执行return语句。这等效于调用`exit()`。
  - 调用`exit()`。此函数由ISO C定义，其清理操作包括调用各终止处理程序，然后关闭所有标准I/O流等。因为ISO C并不处理`fd`、多进程以及作业控制，所以这一定义对于unix系统而言是不完整的。
  - 调用`_exit()` 或`_Exit()`。ISO C定义`_Exit`其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。在unix系统中，`_exit()`和` _Exit()`是同义的，并不冲洗标准I/O流。`exit()`会调用`_exit()`，处理unix系统特定的细节。
  - 进程的最后一个线程在其启动例程中执行`return`语句。但是该线程的返回值不用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。
  - 进程的最后一个线程调用`pthread_exit()`。这种情况下，进程的终止状态总是0，与传送给`pthread_exit()`的参数无关。
- 3种异常终止方式有：
  - 调用`abort()`。它产生`SIGABRT`信号，这是下一种异常终止的特例。
  - 当进程接受到某些信号时。信号可由进程自身、其他进程或内核产生。
  - 最后一个线程对“取消”(cancellation)请求作出响应。默认情况下，“取消”以延迟方式方式：一个线程要求取消另一个线程，若干时间之后，目标线程终止。

不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开的fd，释放它所使用的资源等。

对于上述任意一种终止情形，我们都希望终止进程能够通知其父进程它如何终止的：

- 对于3个终止函数(`exit`、`_exit`、`_Exit`)，实现这一点的方法是，将其退出状态(exit status)作为参数传送给函数。

> 在最后调用`_exit()`时，内核将退出状态转换成终止状态。

- 在异常终止情况，内核(不是进程本身)产生一个指示其异常终止原因的终止状态(termination status)。

在任意一种情况下，该终止进程的父进程都能用`wait()`或`waitpid()`取得其终止状态。

如果父进程在子进程之前终止，，那么子进程(孤儿进程)的父进程会改变为`init`进程，称作`init`进程收养。其操作过程大致是：

1. 在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程。
2. 如果是，则该进程的父进程id更改为1。这样保证了每个进程都有一个父进程。

若子进程在父进程之前终止， 分两种情况：

- 内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用`wait()`或`waitpid()`时，可以得到这些信息。

> 这些信息至少包括进程id、该进程的终止状态以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有内存区，关闭其所有打开文件。

- 一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息，释放它扔占用的资源)的进程被称为僵死进程(zombie)。

> ps(1)命令将僵死进程的状态打印为Z。

因为`init`被编写成无论如何只要有一个子进程终止，`init`就会调用一个`wait()`取得其终止状态。以防止在系统中塞满了僵死进程。

### 8.6函数wait和waitpid

> 当一个进程正常或异常终止时，内核就会向其父进程发送`SIGCHLD`信号。因为子进程终止是个异步事件(即可在父进程运行的任何时候发生)，所以这种信号也是内核向父进程发送的异步信号。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数(信号处理程序)。对于这种信号的系统默认动作时忽略它。

父进程调用`wait()`或`waitpid()`的行为：

- 若其所有子进程都还在运行，则阻塞。
- 若一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态并立即返回。
- 若它没有任何子进程，则立即出错返回。

```c
#include<sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);
//两个函数的返回值：若成功，返回进程id；若出错，返回0或-1
```

这两个函数的区别如下：

- 在一个子进程终止前，`wait()`使其调用者阻塞，而`waitpid()`有一选项，可使调用者不阻塞。
- `waitpid()`并不等待在其调用之后的第一个终止子进程，它有若干个选择，可以控制它所等待的进程。

这两个函数的参数`statloc`是一个整型指针。如果`statloc`不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态，则可将该参数设为`NULL`。

这两个函数返回的整型状态字(参数`statloc`)是由系统实现定义的。其中某些位表示退出状态(正常返回)，其他位则表示信号编号(异常返回)。POSIX.1规定，终止状态用定义在`<sys/wait.h>`中的各个宏来查看。有四个互斥的宏可用来取得进程终止原因：

- `WIFEXITED(status)`：若为正常终止子进程返回的状态，则为真。对于这种情况可执行`WEXITSTATUS(status)`，获取子进程传送给`exit()`或`_exit()`参数的低8位。
- `WIFSIGNALED(status)`：若为异常终止子进程返回的状态，则为真(接到一个不捕捉的信号)。对于这种情况，可执行`WTERMSIG(status)`，获取子进程终止的信号编号。另外有些实现(非SUS)定义宏`WCOREDUMP(status)`，若已产生终止进程的core文件，则它为真。
- `WIFSTOPPED(status)`：若为当前暂停子进程的返回状态，则为真。对于这种情况，可执行`WSTOPSIG(status)`，获取使子进程暂停的信号编号。
- `WIFCONTINUED(status)`：若在作业控制暂停后已经继续的子进程返回了状态，则为真(POSIX.1的XSI扩展，仅用于`waitpid()`)。

POSIX.1定义了`waitpid()`以提供等待一个指定进程的终止，利用参数`pid`指定函数行为：

- 若`pid` == 1：等待任一子进程。这种情况下，`waitpid()`与`wait()`等效。
- 若`pid` > 0：等待进程id与`pid`相等的子进程。
- 若`pid` == 0：等待组id等于带哦用进程组id的任一子进程。
- 若`pid` < -1：等待组id等于`pid`绝对值的任一子进程。

`waitpid()`返回终止子进程的进程id，并将该子进程的终止状态存放在由`statloc`指向的内存中。

> 对于`waitpid()`，若指定的进程或进程组不存在，或参数`pid`指定的进程不是调用进程的子进程，都可能出错。

参数`options`可控制`waitpid()`行为，此参数或为0，或为下列常量按位或运算：

- `WCONTINUED`：若实现支持作业控制，那么由`pid`指定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态(XSI)。
- `WNOHANG`：若由`pid`指定的子进程并不是立即可用的，则`waitpid()`不阻塞，此时其返回值为0。
- `WUNTRACED`：若某实现支持作业控制，而由`pid`指定的任一子进程已处于停止状态，并且其状态自停止以来还未报告过，则返回其状态，`WIFSTOPPED`宏确定返回值是对应一个停止的子进程。

### 8.7函数waitid

SUS包括了另一个取得进程终止状态的函数——`waitid()`，此函数类似于`waitpid()`，但允许一个进程指定要等待的子进程。使用两个单独的参数表示要等待的子进程所属的类型，而不是将此与进程id或进程组id组合成一个参数。

```c
#include<sys/wait.h>
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
//函数的返回值：若成功，返回0；若出错，返回-1
```

参数`id`的作用与`idtype`的值相关。该函数支持的`idtype`类型如下：

- `P_PID`：等待一特定进程，`id`包含要等待子进程的进程id。
- `P_PGID`：等待一特定进程组中的任一子进程，`id`包含要等待子进程的进程组id。
- `P_ALL`：等待任一子进程，忽略`id`。

参数`options`由各标志的按位或运算组成：

- `WCONTINUED`：等待一进程，它以前曾被停止，此后又已继续，但其状态尚未报告。
- `WEXITED`：等待已退出的进程。
- `WNOHANG`：如无可用的子进程退出状态，立即返回而非阻塞。
- `WNOWAIT`：不破坏子进程退出状态。该子进程退出状态可由后续的`wait()`、`waitpid()`或`waitpid()`调用取得。
- `WSTOPPED`：等待一进程，它已经停止，但其状态尚未报告。

`WCONTINUED`、`WEXITED`或`WSTOPPED`这三个常量之一必须在`options`参数中指定。(等待行为)

参数`infop`是指向`siginfo`结构的指针。该结构包含了造成子进程状态改变有关信号的详细信息。

### 8.8函数wait3和wait4

从unix系统的BSD分支沿袭下来的`wait3()`和`wait4()`额外允许内核返回由终止进程及其所有子进程使用的资源情况。

```c
#include<sys/types.h>
#include<sys/wait.h>
#include<sys/times.h>
#include<sys/resource.h>
pid_t wait3(int, *statloc, int options, struct reusage *reusage);
pid_t wait4(pid_t pid, int *statloc, int options, struct reusage *reusage);
//两个函数的返回值：若成功，返回进程id；若出错，返回-1
```

资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数(缓存命中)、接收到信号的次数等。

### 8.9竞争条件

当多个进程都企图对共享数据进行处理，而最后的结果又取决于进程运行的顺序时，则认为发生了竞争条件(race condition)。

> 主要是执行顺序与资源使用的矛盾。

重复循环直至依赖条件为真(可能进程终止了也不为真)的循环被称为轮询(polling)，也被称为自旋(spin)。与阻塞相比，浪费CPU资源。

为避免竞争条件和轮询，在多个进程之间可以使用某种形式的信号发送和接收的方法。在unix中可使用信号机制、进程间通信。

### 8.10函数exec

当进程调用一种`exec`函数时，该进程执行的程序完全替代为新程序，而新程序则从其`main`函数开始执行。因为调用`exec`并不创建新进程，所以前后的进程id并不改变。

> `exec`只是用磁盘上一个新程序替换了当前进程的.text段、数据段、堆和栈。

有7种不同的`exec`函数可供使用：

```c
#include<unistd.h>
int execl(const char *pathname, const char *arg0, ... /* (char *)0 */);
int execv(const char *pathname, char *const argv[]);
int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *cosnt envp[] */);
int execve(const char *pathname, char *const argv[], char *const envp[]);
int execlp(const char *filename, const char *arg0, ... /* (char *)0 */);
int execvp(const cahr *filename, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
//七个函数的返回值：若成功，不返回；若出错，返回-1
```

 这些函数之间的区别有：

- 前四个函数取路径名作为参数，后两个函数则取文件名作为参数，最后一个取`fd`作为参数。当指定`filename`作为参数时：
  - 若`filename`中包含`/`，则就将其视为路径名。
  - 否则就按`PATH`环境变量，在它所指定的各目录中搜寻可执行文件。(P表示PATH)

- 参数表的传递不同。
  - 含l的函数`execl()`、`execlp()`、`execle()`要求将新程序的每个命令行参数都说明为一个单独的参数，这种参数表以空指针结尾。(l表示list列表)
  - 含v的函数`execv()`、`execvp()`、`execve()`和`fexecve()`则先构建一个指向个参数的指针数组，然后将该数组地址作为参数。(v表示vector矢量)
- 向新程序传递环境表不同。
  - 以e结尾的三个函数`execle()`、`execve()`和`fexecve()`可以传递一个指向环境字符串指针数组的指针。(e表示environ)
  - 其他4个函数则使用调用进程的`environ`变量作为新程序复制现有的环境。

> 每个系统对参数表和环境表的总长度都有一个限制。由`ARG_MAX`给出。
>
> 为了摆脱对参数表长度的限制，可以使用xargs(1)命令，将长参数表断开成几部分。

在执行`exec`后，新程序从调用进程继承了下列属性：

- 标识符类：(程序的设置id会变为新程序文件的设置id，设置组id同理)
  - 进程id和父进程id
  - 实际用户id和实际组id
  - 进程组id和附属组id
  - 会话id
- 进程环境类：
  - 控制终端
  - alarm尚余留的时间
  - 当前工作目录
  - 根目录
  - 创建文件时的权限屏蔽字
  - 文件锁
  - 进程信号屏蔽字
  - 未处理信号
  - 资源限制
  - 友好值(遵循XSI的系统)
  - `tms_utime`、`tms_stime` 、`tms_cutime`以及`tms_cstime`

对于打开文件的处理以及每个`fd`的执行时关闭(close-on-exec)标志值有关。

- 若设置了`FD_CLOEXEC`标志，则在执行`exec`时关闭该`fd`。
- 若未设置则该`fd`在`exec`后仍打开。除非用`fcntl()`设置了该标志位，都则系统默认未设置。

> POSIX.1明确要求在`exec`时关闭打开目录流(`opendir()`的内部实现使用了`fcntl()`)

有效用户id和有效用户组id是否改变则取决于所执行程序文件的设置用户id和设置组id位是否设置：

- 若新程序的设置用户id位已设置，则有效用户id变成程序文件所有者的id。
- 否则有效用户id不变。

> 对有效组id的处理方式相同。

### 8.11更改用户id和更改组id

调用`setuid()`设置实际用户id和有效用户id，`setgid()`设置实际组id和有效组id。

```c
#include<unistd.h>
int setuid(uid_t uid);
int setgiud(gid_t gid);
//两个函数的返回值：若成功，返回0；若出错，返回-1
```

更改用户id的规则(同样适用于组id)：

- 若进程具有root用户权限，则`setuid()`将实际用户id、有效用户id以及保存的设置用户id(saved set-user-id)设置为uid。
- 若进程没有root用户权限，但是uid等于实际用户id或保存的设置用户id，则`setuid()`只将有效用户id设置为uid。不更改实际用户id和保存的的设置用户id。
- 若上面两个条件都不满足，则`errno`设置为`EPERM`，并返回-1。

> 在此假定`_POSIX_SAVED_IDS`为真。若没有提供这种功能，则上面所说的关于保存的设置用户id部分都无效。

关于内核所维护的3个用户id还需注意以下几点：

- 只有root用户进程可以更改实际用户id。
- 仅当对程序文件设置了设置用户id位时，`exec`函数才设置有效果用户id为设置用户id。
- 若程序文件设置了设置用户id，`exec`后将复制旧有效用户id给保存的设置用户id。

> `getuid()`和`geteuid()`只是用来获取实际用户id和有效用户id。目前无可移植的方法获取保存的设置用户id的当前值。

#### 8.11.1函数setreuid和setregid

历史上，BSD支持`setreuid()`，其功能是交换实际用户id和有效用户id的值。

```c
#include<unistd.h>
int setreuid(uid_t ruid, uid_t euid);
int setregid(gid_t rgid, git_t egid);
//两个函数的返回值：若成功，返回0；若出错，返回-1
```

若其中任一参数的值为-1，则表示相应的id应保持不变。

对于非root用户总能交换实际用户id和有效用户id。这也就允许一个设置用户id程序交换成普通权限后又可再次交换回设置用户id权限。

POSIX.1引进了保存的设置用户id特性后，允许一个非root用户将其有效用户id设置为保存的设置用户id。

#### 8.11.2函数seteuid和setegid

POSIX.1包含了两个函数`seteuid()`和`setegid()`只更改有效用户id和有效组id。

```c
#include<unistd.h>
int seteuid(uid_t uid);
int setegid(gid_t gid);
//两个函数的返回值：若成功，返回0；若出错，返回-1
```

对于非root用户可将其有效用户id设置为其实际用户id或其保存的设置用户id。

对于root用户则将有效用户id设置为uid。而`setuid()`更改所有3个用户id。

#### 8.11.3组id

以上所有类似方法均适用于各组id。但附属组id不受`setgid()`、`setregid()`和`setegid()`的影响。

### 8.12解释器文件

所有现今的unix系统都支持解释器文件(interpreter file)。这种文件是文本文件，其起始行的形式是：`#！ pathname [optional-argument]`。在感叹号和`pathname`之间的空格是可选的。

> 最常见的解释器文件以下列行开始：`#! /bin/sh`。

`pathname`通常是绝对路径名。对这种文件的识别是由内核作为`exec`系统调用处理的一部分来完成的。

### 8.13函数system



### 8.14进程会计



### 8.15用户标识

系统通常记录用户登录时使用的名字，用`getlogin()`可以获取此登录名。

```c
#include<unistd.h>
char *getlogin(void);
//函数的返回值：若成功，返回指向登录名字符串的指针；若出错，返回NULL
```

若调用此函数的进程没有连接到用户登录时所用的终端，则函数会失败。通常称这些进程为守护进程(darmon)。

> 获取了登录名，就可用`getpwnam()`在口令文件中查找用户的相应记录，从而确定其登录shell等。

### 8.16进程调度

SUS中友好值的范围在`0～(2*NZERO)-1`之间，有些实现支持`0～2*NZERO`。友好值越小，优先级越高。

> 柿子规则：进程越友好，调度优先级就越低。`NZERO`是系统默认的友好值。

进程可以通过`nice()`获取或更改它的友好值。使用这个函数，进程只能影响自己的友好值，不能影响任何其他进程的友好值。

```c
#include<unistd.h>
int nice(int incr);
//函数的返回值：若成功，返回新的友好值NZERO；若出错，返回-1
```

参数`incr`被增加到调用进程的友好值上。

- 若`incr`太大，系统直接把它降到最大合法值，不给提示。

- 若`incr`太小，系统也会无声息地把它提高到最小合法值。

由于-1是合法的成功返回值，在调用`nice()`之前需要清除`errno`，在`nice()`返回-1时，需要检查它的值。

- 若函数返回值为-1并且`errno`仍为0，则调用成功。
- 若函数返回值为-1但`errno`不为0，则调用失败。

`getpriority()`可以像`nice()`那样用于获取进程的友好值，但是`getpriority()`还可以获取一组相关进程的友好值。

```c
#include<sys/resource.h>
int getpriority(int which, id_t who);
//函数的的返回值：若成功，返回-NZERO～NZERO-1之间的友好值；若出错，返回-1
```

参数`which`可以取一下三个值之一：

- `PRIO_PROCESS`：表示进程
- `PRIO_PGRP`：表示进程组
- `PRIO_USER`：表示用户id

参数`which`控制参数`who`的行为：

- 若`who`为0，采用的是进程的实际用户id，来查询调用进程、进程组或者用户(取决于参数`which`的值)。
- 若`who`不为0，则采用的是与其相等的用户id，来查询。

`setpriority()`可用于为进程、进程组和属于特定用户id的所有进程设置优先级。

```c
#include<sys/resource.h>
int setpriority(int which, id_t who, int value);
//函数的返回值：若成功，返回0；若出错，返回-1
```

参数`which`和`who`的取值与`getpriority()`中相同。`value`为增加到`NZERO`上的值，然后变为新的友好值。

> SUS并未规定子进程是否继承友好值，但XSI要求进程调用`exec`后保留友好值。

### 8.17进程时间

任一进程都可调用`times()`以获取他自己以及已终止子进程的墙上时钟时间、用户CPU时间以及系统CPU时间。

```c
#include<sys/times.h>
clock_t times(struct tms *buf);
//函数的返回值：若成功，返回流逝的墙上时钟时间(以时钟滴答数为单位)；若出错，返回-1
```

此函数参数`buf`指向的`tms`结构如下：

```c
struct tms {
	clock_t tms_utime;           //用户CPU时间(user CPU time)
	clock_t tms_stime;					 //系统CPU时间(system CPU time)
	clock_t tms_cutime;					 //已终止子进程的用户CPU时间(user CPU time, terminated children)
	clock_t tms_cstime;					 //已终止子进程的系统CPU时间(system CPU time, terminated children)
};
```

> 注意，此结构没有包含墙上时钟时间，`times()`将墙上时钟时间作为函数的返回值。此值时相对于过于某一时刻度量的，所以不能用其绝对值而必须使用其相对值。

所有由此函数返回的`clock_t`值都可用`sysconf(_SC_CLK_TCK)`转换成秒数。
