## 13守护进程

### 13.2守护进程的特征

ps(1)命令打印系统中各个进程的状态。

- `-a`显示包含其他用户所拥有的进程的状态。

- `-x`显示没有控制终端的进程状态。

- `-j`显示与作业有关的信息：会话id、进程组id、控制终端以及终端进程组id。

```bash
$bash: ps -axj
```

父进程id为0的各进程通常是内核进程，它们作为系统引导装入过程的一部分而启动。内核进程通常存在于系统的整个生命期中。以root用户运行，无控制终端，无命令行。

> init是个例外，它是由内核在引导装入时启动的用户层次的命令。

所有的守护进程都没有控制终端，在ps的输出实例中其终端名为问号。

- 内核守护进程以无控制终端方式启动。在ps的输出实例中，内核守护进程的名字出现在方括号中。
- 用户层守护进程缺少控制终端可能是守护进程调用 了`setsid()`的结果。

大多数用户层守护进程都是进程组的组长进程以及会话的首进程，而且是这些进程组和会话中的唯一进程(rsyslogd是一个例外)。所有用户层守护进程的父进程都是init进程。

### 13.3编程规则

在编写守护进程程序时需遵循一些基本规则，以防止产生不必要的交互作用：

1. 调用`umask()`将文件模式创建屏蔽字设置为一个已知值(通常是0)。
2. 调用`fork()`，然后使父进程exit。保证了子进程不是一 个进程组的组长进程，这是调用`setsid()`的先决条件。
3. 调用`setsid()`创建一个新会话。使调用进程：(a)成为新会话的首进程，(b)成为一个新进程组的组长进程，(c)没有控制终端。

> 此时再次调用`fork()`，终止父进程，继续使用子进程中的守护进程。保证了该守护进程不是会话首进程，防止它取得控制终端。
>
> 为了避免取得控制终端的另一种方法是，无论何时打开一个终端设备，都一定要指定`O_NOCTTY`。

4. 调用`chdir()`更改进程的当前工作目录，可为根目录；也可为某个指定位置，并在此位置进行它们的全部工作。
5. 关闭不再需要的文件描述符。
6. 某些守护进程打开`/dev/null`使其具有文件描述符0、1和2。

### 13.4出错记录

有3种产生日志消息的方法：

- 内核例程可以调用`log()`。任何一个用户进程都可以通过打开(open)并读取(read)`/dev/klog`设备来读取这些消息。
- 大多数用户进程(守护进程)调用`syslog()`来产生日志消息。使消息被发送至UNIX域数据报套接字`/dev/log`。
- 无论一个用户进程是在此主机上，还是在通过TCP/IP网络连接到此主机的其他主机上，都可将日志消息发向UDP端口514。

> `syslog()`从不产生这些UDP数据报，它们要求产生此日志消息的进程进行显式的网络编程。

通常，syslogd守护进程读取所有3种格式的日志消息。此守护进程在启动时读`/etc/syslog.conf`配置文件，该文件决定了不同种类的消息应送向何处。该进程的接口是`syslog()`。

调用`openlog()`是可选择的。如果不调用`openlog()`，则在第一次调用`syslog()`时，会自动调用`openlog()`。

调用 `closelog()`也是可选择的，因为它只是关闭曾被用于与syslogd守护进程进行通信的`fd`。

```c
#include <syslog.h>
void openlog(const char *ident, int option, int facility); 
void syslog(int priority, const char *format, ...);
void closelog(void);
int setlogmask(int maskpri);
//函数的返回值：前日志记录优先级屏蔽字值
```

参数`ident`为日志标识，此`ident`将被加至每则日志消息中。一般被设为程序名(如cron、inetd)。

参数`option`是指定各种选项的位屏蔽。

- `LOG_CONS`，若消息不能通过UNIX域数据报送至syslogd，则将该消息写至控制台。
- `LOG_NDELAY`，不等第一条消息已经被记录时，立即打开套接字。
- `LOG_NOWAIT`，不等待在将消息记入日志过程中可能已创建的子进程。
- `LOG_ODELAY`，在第一条消息被记录前延迟打开至syslogd守护进程的连接。
- `LOG_PERROR`，除将诶之消息发送给syslogd以外，还将它写至标准出错。
- `LOG_PID`，记录每条消息都包含进程id。

参数`facility`的目的是可以让配置文件说明，来自不同设施的消息将以不同的方式进行处理。

调用`syslog()`产生一个日志消息，参数`priority`是`facility`和`level`的组合。

调用`setlogmask()`用于设置进程的记录优先级屏蔽字，并返回上次调用的屏蔽字。当设置了记录优先级屏蔽字时，各条消息除非已在记录优先级屏蔽字中进行了设置，否则将不被记录。

> 试图将记录优先级屏蔽字设置为0并不会有什么作用。

除了`syslog()`，很多平台还提供它的一种变体来处理可变参数列表。

```c
#include <syslog.h>
#include <stdarg.h>
void vsyslog(int priority, const char *format, va_list arg); 
```

### 13.5单实例守护进程

为了正常运作，某些守护进程会实现为，在任一时刻只运行该守护进程的一个副本。

文件和记录锁机制保证了单实例守护进程：

- 若每一个守护进程创建一个有固定名字的文件，并在该文件的整体上加 一把写锁，且只允许创建一把。之后尝试创建写锁都会失败。

- 若守护进程在一个文件的整体上得到一把写锁，那么在该守护进程终止时，这把锁才被自动删除。

### 13.6守护进程的惯例

在UNIX系统中，守护进程遵循下列通用惯例。

- 若守护进程使用文件和记录锁，那么该文件通常存储在`/var/run`目录中。守护进程可能需要root用户权限才能在此目录下创建文件。文件名为`name.pid`，`name`是该守护进程或服务的名字。
- 若守护进程支持配置选项，那么配置文件通常存放在`/etc`目录中。配置文件名为`name.conf`，`name`是该守护进程或服务的名字。
- 守护进程可用命令行启动，但通常它们是由系统初始化脚本之一 (`/etc/rc*`或`/etc/init.d/*`)启动的。如果在守护进程终止时，应当自动地重新启动它，则我们可在`/etc/inittab`中为该守护进程包括respawn记录项，这样init进程就将重新启动该守护进程。
- 若一个守护进程有一个配置文件，那么当该守护进程启动时会读该文件，但在此之后一般就不会再查看它。若更改了配置文件，那么该守护进程可能需要被停止，然后再启动，以使配置文件 的更改生效。为避免此种麻烦，某些守护进程将捕捉`SIGHUP`信号，当接收到`SIGHUP`信号时，该线程调用函数重读它的配置文件。

> 因为守护进程并不与终端相结合，它们或者是无控制终端的会话首进程，或者是孤儿进程组的成员，所以守护进程没有理由期望接收`SIGHUP`。于是，守护进程可以安全地重复使用`SIGHUP`。

- 当它接收到`SIGTERM`信号时，守护进程会记录消息并退出。

### 13.7客户进程-服务器进程模型

可以在服务器进程中调用`fork()`然后`exec`另一个程序来为客户进程提供服务。

利用多进程处理客户端业务时，服务器进程通常管理着多个`fd`，对所有被执行程序不需要的`fd`设置执行时关闭(close-on-exec)标志，使得子进程只包含对应客户业务的`fd`。

