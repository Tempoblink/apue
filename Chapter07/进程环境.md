## 7进程环境

### 7.2main函数

c程序总是从`main`函数开始执行。`main`的函数原型是

```c
int main(int argc, char *argv[]);
```

其中，`argc`是命令行参数的数目，`argv`是指向参数的各个指针所构成的数组。

当内核执行c程序时，在调用`main`前先调用一个特殊的启动例程(`exec`调用`exit(main(argc, argv));`)。

可执行文件将此启动例程指定为程序的起始位置——这是由链接器设置的，而链接器由c编译器调用。

启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用`main`做好准备。

### 7.3进程终止

有8种方式使进程终止(termination)，其中5中为正常终止，3种异常终止：

- 正常终止方式：
  1. 从`main`返回
  2. 调用`exit()`
  3. 调用`_exit()`或`_Exit()`
  4. 最后一个线程从启动例程中返回
  5. 从最后一个线程调用`pthread_exit()`

- 异常终止方式：
  1. 调用`abort()`
  2. 收到一个信号
  3. 最后一个线程对取消请求作出响应

#### 7.3.1退出函数

下列3个函数用于正常终止一个程序：`_exit()`和`_Exit()`立即返回内核区，

`exit()`内部会先执行一些清理处理，然后调用`_exit()`或`_Exit()`返回内核区。

```c
#include<stdlib.h>
void exit(int status);
void _Exit(int status);
#include<unistd.h>
void _exit(int status);
```

3个退出函数都带一个整型参数，称为终止状态(或退出状态，exit status)。大多数unix系统shell都提供检查进程终止状态的方法。

进程的终止状态在以下情况是为定义的：

1. 若调用这些函数不带终止状态
2. 若`main`执行了一个无返回值的`return`语句
3. 若`main`没有声明返回类型为整型

> 若`main`的返回类型是整型，并执行到最后一条语句时返回(隐式返回)，则该进程的终止状态时0。
>
> `exti(0)` 等价于 `return(0)`。

#### 7.3.2函数atexit

调用`atexit()`可注册终止处理程序(exit handler)，按照ISO C的规定，进程可以注册多至32个函数，这些函数将由`exit()`自动调用。

```c
#include<stdlib.h>
int atexit(void (*func)(void));
//函数的返回值：若成功，返回0；若出错，返回非0
```

`exit()`调用这些函数的顺序与其注册时的顺序相反。同一函数若注册多次，也会被调用多次。

根据ISO C和POSIX.1，`exit()`会先调用各种终止处理程序，然后再关闭所有打开流。

POSIX.1扩展了ISO C标准：若程序调用`exec`函数族中的任一函数，则将清除所有已注册的终止处理程序。

> 内核执行程序的唯一方法是调用`exec`函数。
>
> 进程自愿终止的唯一方法是显示或隐式地调用`_exit`或`_Exit`。进程也可非自愿地被一个信号(`SIGKILL`或`SIGQUIT`)终止。

### 7.4命令行参数

ISO C和POSIX.1要求`argv[argc]`是一个空指针，即命令行参数以`NULL`结尾。

### 7.5环境表

每个进程都有一张环境表。

- 与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以`null`结尾的c字符串(环境字符串)的地址。

- 全局变量`environ`包含了该指针数组的地址：`extern char **environ;`(环境指针)。
- 环境由`name = value`这样的字符串组成。大多数预定义名完全由大写字母组成。

> 通常用`getenv()`和`putenv()`来访问特定的环境变量，而不是用`environ`变量。但是若要查看整个环境，则必须使用`environ`指针。

### 7.6C程序的内存空间布局

C程序一直由下列几部分组成：

- .text段。这是由CPU执行的机器指令部分。
  - 通常.text段是可共享的，所以即使是频繁执行的程序在内存中也只需要一个副本。
  - 为防止程序由于意外而被修改指令，.text段常常是只读的。
- .data段。它包含了程序中需明确地赋初值的变量，包含已初始化的全局和静态变量。
- .bss段。它包含了未初始化的全局和静态变量，以及所有被初始化为0的全局或静态变量。
- 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。
- 堆。通常在堆中进行动态存储分配。其位于.bss段和栈之间。

.bss段的内容并不存放在磁盘程序文件中，因为内核在程序开始运行前将它们都设置为0。需要存放在磁盘程序文件中的段只有正文段和.data段。

> 通常栈从高地址向低地址方向增长，堆顶和栈顶之间为用的虚拟空间地址很大。

### 7.7共享库

共享库使得可执行文件中不再需要包含公用的库函数，而只需在所有进程都引用的内存区中保存该库例程的一个副本。

程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接(链接器)。共享库的优点：

- 减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者被每个共享库函数第一次被调用时。

- 用库函数的新版本代替老版本而无需对使用该库的程序重新链接编译。

### 7.8存储空间分配

ISO C说明了三个用于内存空间动态分配的函数。

```c
 #include<stdlib.h>
 void *malloc(size_t size);
 void *calloc(size_t nobj, size_t size);
 void *realloc(void *ptr, size_t newsize);
//三个函数的返回值：若成功，返回非空指针；若出错，返回NULL
 void free(void *ptr);
```

`malloc()`分配指定字节数的内存区。此内存区中的初始值未知。

`calloc()`为指定数量指定长度的对象分配内存空间。该空间中的每一位(bit)都初始化为0。

`realloc()`增加或减少以前分配区的长度。当增加长度时，可能需将旧分配区的内容移到另一个足够大的区域，以便在尾端提供增加的内存区，而新增区域内的初始值则不确定。

- 若旧内存区后有充足空间，则原地扩充，否则开辟新的内存区，并拷贝释放旧内存区。

- 参数`newsize`是申请的新内存区的长度，不是新、旧内存区的差值。


- 若参数`ptr`为`NULL`，则`realloc`等效于`malloc`，用于分配一个指定长度为`newsize`的内存区。


> 这三个分配函数所返回的指针一定是适当对齐的，使其可用于任何数据对象。

若在程序中包括了`#include<stdlib.h>`，通用指针赋值给其他类型指针时，不需要显示地强制类型转换。

> 未声明函数返回值的的默认返回类型为int，而int类型的长度可能与函数返回类型值的字节大小不同，所以使用没有正确函数声明的强制类型转换可能会隐藏系统错误。

调用`free()`会释放参数`ptr`指向的内存空间。被释放的内存空间通常被送入可用内存区池。

对堆区内存可能产生致命性错误的有：

1. 在动态分配的缓冲区前或后进行写操作，可能会改写该区的管理记录信息，也可能破坏其他已分配内存的对象。
2. 释放一个已经释放了的块
3. 调用`free()`时所用的指针不是这三个函数的返回值(`ptr++`)；
4. 在一个进程中不调用`free()`释放不再使用的内存空间，该进程占用的内存空间将增加，造成内存泄漏(leakage)。

### 7.9环境变量

ISO C定义了一个函数`getenv()`，可以用来获取环境变量值。

```c
#include<stdlib.h>
char *getenv(const char *name);
//函数的返回值：指向与name关联的value的指针；若未找到，返回NULL
```

下列函数用于改变现有环境变量的值或增加新的环境变量。

```c
#include<stdlib.h>
int putenv(char *str);
//函数的返回值：若成功，返回0；若出错，返回非0
int setenv(const char *name, const char *value, int rewrite);
int unsetenv(const char *name);
//两个函数的返回值：若成功，返回0；若出错，返回-1
```

`putenv()`参数`str`的形式为`name=value`的字符串，将其放到环境表中。如果`name`已经存在，则先删除其原来的定义。

`setenv()`在环境表中将`name`的值设为`value`。如果在环境中`name`已经存在，那么：

- 若`rewrite`非0，则首先删除其现有的定义。
- 若`rewrite`为0，则不删除其现有定义(`name`不设置为新的`value`，而且也不出错)。

`unsetenv()`删除`name`的定义。即使不存在这种定义也会出错。

### 7.10函数setjump和longjump

在C中，`goto`语句是不能跨越函数的，而执行种类型跳转功能的是函数`setjmp()`和`longjmp()`。这两个函数对于处理发生在深层嵌套函数调用种的出错情况是非常有用的。

```c
#include<setjmp.h>
int setjmp(jmp_buf env);
//函数的返回值：若直接调用，返回0；若从longjmp返回，则为非0
void longjmp(jmp_buf env, int val);
```

在希望返回的位置调用`setjmp()`。其参数`env`的类型是一个特殊类型`jmp_buf`。该类型是存放在调用`longjmp()`时能用来恢复栈状态的所有信息的数组。因为需要在另外一个函数中引用`env`变量，所以通常将`env`变量定义为全局变量。

`longjmp()`的第一个参数`env`是调用`setjmp()`时所用的`env`，即希望跳转到的栈的某时的状态`env`，第二个参数是具非0值的`val`，它将成为`setjmp()`处的返回值。

> 使用第二参数的原因是对于一个`setjmp()`可以有多个`longjmp()`。

#### 7.10.1自动变量、寄存器变量和易失变量

若存在一个自动变量，而又不想使其值回滚，则可定义其为具有`volatile`属性。声明为全局变量或静态变量的值在执行`longjmp()`是保持不变。

> 编译不进行优化时，声明为寄存器类型的变量存在内存区；而编译器进行优化时，自动变量和寄存器变量都存在寄存器中。

#### 7.10.2自动变量的潜在问题

根据栈帧的处理方式，声明自动变量的函数已经返回后，则不能再引用这些自动变量。(自动变量如其名：函数返回，自动回收。)

### 7.11函数getrlimit和setrlimit

每个进程都有一组资源限制，其中一些可用`getrlimit()`和`setrlimit()`查询和更改。

```c
#include<sys/resource.h>
int getrlimit(int resource, struct rlimit *rlptr);
int setrlimit(int resource, const struct rlimit *rlptr);
//两个函数的返回值：若成功，返货0；若出错，返回非0
```

结构`rlimit`定义如下：

```c
struct rlimit {
	rlim_t rlim_cur;							//软限制：当前限制值
  rlim_t rlim_max;							//硬限制：当前限制的最大值
}
```

在更改资源限制时，必须遵守下列3条规则。 (软限制 <= 硬限制)

1. 任何一个进程都可将一个软限制值更改为小于或等于其硬限制值。
2. 任何一个进程都可降低其硬限制值，但它必须大于或等于其软限制值。这种降低，对普通用户而言是不可逆的。
3. 只有root用户进程可以提高硬限制值。

> 常量`RLIM_INFINITY`指定了一个无限量的限制。

参数`resource`可取值为：

- `RLIMIT_AS`：进程总可用内存空间的最大长度(字节)。这影响到`sbrk()`和`mmap()`。
- `RLIMIT_CORE：core`文件的最大字节数，若其值为0则阻止创建core文件。
- `RLIMIT_CPU：CPU`时间的最大量值，当超过此软限制时，向该进程发送`SIGXCPU`信号。
- `RLIMIT_DATA`：数据段的最大字节长度。这是.data段、.bss段以及堆的总和。
- `RLIMIT_FSIZE`：可以创建的文件的最大字节长度。当超过此软限制时，则向该进程发送`SIGXFSZ`信号。
- `RLIMIT_MEMLOCK`：一个进程使用`mlock`(2)能够锁定在内存空间中的最大字节长度。
- `RLIMIT_MSGQUEUE`：进程为POSIX消息队列可分配的最大存储字节数。
- `RLIMIT_NICE`：为了影响进程的调度优先级，友好值可设置的最大限制。
- `RLIMIT_NOFILE`：每个进程能打开的最多文件数。更改此限制将影响到`sysconf(_SC_OPEN_MAX)`的返回值。
- `RLIMIT_NPROC`：每个实际用户id可拥有的最大子进程数。更改此限制将影响到`sysconf(_SC_CHILD_MAX)`的返回值。

- `RLIMIT_NPTS`：用户可同时打开的伪终端的最大数量。
- `RLIMIT_RSS`：最大驻内存集字节长度(resident set size in bytes，RSS)。如果可用的物理内存较少，则内核将从进程处取回超过RSS的部分。
- `RLIMIT_SBSIZE`：在任一给定时刻，一个用户可以占用的套接字缓冲区的最大长度(字节)。
- `RLIMIT_SIGPENDING`：一个进程可排队的信号最大数量。这个限制时`sigqueue()`实施的。
- `RLIMIT_STACK`：栈的最大字节长度。
- `RLIMIT_SWAP`：用户可消耗的swap空间的最大字节数。
- `RLIMIT_VMEM`：这是`RLIMIT_AS`的同义词。

> 资源限制影响到调用进程并由其子进程继承。

